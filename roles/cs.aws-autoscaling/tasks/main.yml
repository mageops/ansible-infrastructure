- name: Create Launch Configuration
  ec2_lc:
    state: present
    name: "{{ autoscaling_launch_configuration_name }}"
    region: "{{ aws_region }}"
    assign_public_ip: "{{ autoscaling_assign_public_ip }}"
    instance_type: "{{ autoscaling_instance_type }}"
    image_id: "{{ autoscaling_instance_ami_id }}"
    security_groups: "{{ autoscaling_instance_security_groups }}"
    instance_profile_name: "{{ autoscaling_instance_iam_role }}"
    key_name: "{{ aws_ec2_ssh_key_name }}"
    instance_monitoring: False
    user_data: "{{ aws_ec2_instance_user_data }}"
    # This has zero costs on current-gen instances
    ebs_optimized: yes
  register: launch_configuration
  vars:
    aws_ec2_user_launch_script: "{{ autoscaling_instance_start_script }}"

- name: Create AutoScaling Group
  ec2_asg:
    state: present
    name: "{{ autoscaling_asg_name }}"
    region: "{{ aws_region }}"
    availability_zones: "{{ aws_app_asg_availability_zones | join(',') }}"
    launch_config_name: "{{ launch_configuration.name }}"
    load_balancers: "{{ autoscaling_loadbalancers | default(omit, true) }}"
    min_size: "{{ autoscaling_asg_min_size }}"
    max_size: "{{ autoscaling_asg_max_size }}"
    desired_capacity: "{{ autoscaling_asg_desired_capacity }}"
    vpc_zone_identifier: "{{ aws_vpc_subnet_id }}"
    default_cooldown: "{{ autoscaling_asg_cooldown }}"
    # Grace period for Healthcheck  tatus when new nodes are going up. 
    # The 300s default we had is waaaay too long for our setup and makes the 
    # deploy much, much longer (at least 300s long).
    health_check_period: "{{ autoscaling_asg_healthcheck_grace_period }}"
    termination_policies: "{{ autoscaling_asg_termination_policies }}"
    tags: "{{ aws_tags_default | combine(asg_name_tags, aws_tags_trait_immutable, autoscaling_instance_tags) | dict_to_tag_list }}"
    # This ansible module does not handle instance replacement properly
    # so we just update the ASG configuration here and will perform the
    # replacement via AWS API in the next steps.
    replace_instances: []
  vars:
    asg_name_tags:
      - Name: "{{ autoscaling_asg_name }}"
  register: _aws_asg

  # wait_for_instances: "{{ autoscaling_asg_wait_for_instances }}"
  # wait_timeout: "{{ autoscaling_asg_wait_timeout }}"

- name: Refresh AutoScaling Group Instances
  command:
    argv: >-
      {{ [ 'aws', 'autoscaling', 'start-instance-refresh' ]
          + aws_asg_instance_refresh_cli_args_base
          + [ '--cli-input-json', aws_asg_instance_refresh_params | to_json ] }}
  vars:
    aws_asg_instance_refresh_params:
      AutoScalingGroupName: "{{ autoscaling_asg_name }}"
      # Note: A futureproof setting - there is no other strategy as of yet.
      Strategy: Rolling
      Preferences:
          MinHealthyPercentage: "{{ aws_asg_rolling_instance_refresh_min_healthy_percent }}"
          InstanceWarmup: "{{ aws_asg_rolling_instance_refresh_extra_warmup_grace_period }}"
  register: aws_asg_instance_refresh_command

- name: Get the current refresh task identifier
  set_fact:
    aws_asg_instance_refresh_id: "{{ ( aws_asg_instance_refresh_command.stdout | from_json ).InstanceRefreshId }}"

- name: Print info about refresh id so it can be tracked
  debug:
    msg: |
      Started ASG rolling instance refresh with id:
      {{ aws_asg_instance_refresh_id }}

- name: Wait for the AutoScaling Group Instance Refresh to complete
  command:
    argv: >-
      {{ [ 'aws', 'autoscaling', 'describe-instance-refreshes' ]
          + aws_asg_instance_refresh_cli_args_base
          + [ '--cli-input-json', aws_asg_instance_describe_refresh_params | to_json ] }}
  vars:
    aws_asg_instance_describe_refresh_params:
      AutoScalingGroupName: "{{ autoscaling_asg_name }}"
      InstanceRefreshIds: [ "{{ aws_asg_instance_refresh_id }}" ]
    aws_asg_instance_describe_data: >- 
      {{ ( aws_asg_describe_instance_refresh_command.stdout 
            | default('{"Status": null, "PercentageComplete": -1}') | from_json ).InstanceRefreshes | first }}
  register: aws_asg_describe_instance_refresh_command
  until: >-
    aws_asg_describe_instance_refresh_command is not failed 
    and aws_asg_instance_describe_data.PercentageComplete | default(-1, true) | int == 100
      and aws_asg_instance_describe_data.Status == 'Successful'
  loop_control:
    label: "{{ item }}"
  delay: 15
  retries: 60

- name: Create ASG Termination Lifecycle Hook
  ec2_asg_lifecycle_hook:
    state: present
    region: "{{ aws_region }}"
    autoscaling_group_name: "{{ autoscaling_asg_name }}"
    lifecycle_hook_name: "{{ autoscaling_webnodedown_hook_name }}"
    transition: "autoscaling:EC2_INSTANCE_TERMINATING"
    heartbeat_timeout: 120
    default_result: CONTINUE
  when: autoscaling_webnodedown_hook_create
